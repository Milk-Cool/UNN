// most of this file was generated by chatgpt and rewritten by me
// please forgive me if there are any errors

import fs from "fs";
import { join } from "path";
import { Jimp, ResizeStrategy } from "jimp";

const RAND_DIGITS_AMOUNT = 500;
const BATCH_SIZE = 32; // RAND_DIGITS_AMOUNT will be rounded to this; RAND_DIGITS_AMOUNT should not be less that BATCH_SIZE / 2

const softMax = (logits: number[]) => {
    const max = Math.max(...logits);
    const exps = logits.map(x => Math.exp(x - max));
    const sum = exps.reduce((a, b) => a + b, 0);
    return exps.map(e => e / sum);
};
type Model = { w: number[][], b: number[] };
const initModel = () => ({
    w: new Array(10).fill(0).map(_x => new Array(256).fill(0).map(_y => (Math.random() - 0.5) * 0.01)),
    b: new Array(10).fill(0)
} as Model);
export const forward = (model: Model, x: number[]) => softMax(model.w.map((row, i) => row.reduce((sum, wj, j) => sum + wj * x[j], model.b[i])));

const train = (model: Model, images: number[][], labels: number[], epochs = 5, lr = 0.3) => {
    for(let epoch = 0; epoch < epochs; epoch++) {
        const idx = [...Array(images.length).keys()];
        for(let i = idx.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [idx[i], idx[j]] = [idx[j], idx[i]];
        }
        let correct = 0;
        for(let i = 0; i < images.length; i += BATCH_SIZE) {
            const gradsW: number[][] = new Array(10).fill(0).map(_x => new Array(256).fill(0)), gradsB: number[] = new Array(10).fill(0);
            for(let n = i; n < Math.min(i + BATCH_SIZE, images.length); n++) {
                const x = images[idx[n]];
                const y = labels[idx[n]];
                const yPred = forward(model, x);
                
                const pred = yPred.indexOf(Math.max(...yPred));
                if(pred === y) correct++;

                const grad = [...yPred];
                grad[y] -= 1;

                for(let k = 0; k < 10; k++) {
                    gradsB[k] += grad[k];
                    for(let j = 0; j < 256; j++)
                        gradsW[k][j] += grad[k] * x[j];
                }
            }

            for(let k = 0; k < 10; k++) {
                gradsB[k] /= BATCH_SIZE;
                for(let j = 0; j < 256; j++)
                    gradsW[k][j] /= BATCH_SIZE;
                model.b[k] -= lr * gradsB[k];
                for(let j = 0; j < 256; j++)
                    model.w[k][j] -= lr * gradsW[k][j];
            }
        }
            
        console.log(`epoch #${epoch + 1}`);
        console.log(`acc = ${((correct / images.length) * 100).toFixed(2)}`);
        console.log();
    }
    return model;
}
const images: number[][] = [];
const labels: number[] = [];
for(let i = 0; i < 10; i++) {
    const a = fs.readdirSync(join("training", "dataset", i.toString()));
    const paths: string[] = [];
    for(let j = 0; j < Math.round(RAND_DIGITS_AMOUNT / BATCH_SIZE) * BATCH_SIZE; j++) {
        let p: string;
        do {
            p = join("training", "dataset", i.toString(), a[Math.floor(Math.random() * a.length)]);
        } while(paths.includes(p));
        
        let pixels = [];
        const img = await Jimp.read(p);
        img.resize({ w: 16, h: 16, mode: ResizeStrategy.BILINEAR });
        for(let y = 0; y < 16; y++)
            for(let x = 0; x < 16; x++) {
                const c = img.getPixelColor(x, y);
                pixels.push((((c >> 16) & 0xff) + ((c >> 8) & 0xff) + ((c >> 0) & 0xff)) / (0xff * 3));
            }
        images.push(pixels);
        labels.push(i);
    }
    console.log("loaded images!", i, 10);
}

const model = initModel();
const json = JSON.stringify(train(model, images, labels, 10000));

fs.writeFileSync(join("training", "weights", "w.json"), json);